# Date: 2024-1-11
# Author: Generated by GoCodeo.

class TestRunPostmanCollection { 
    async runPostmanCollection(collectionPath) { 
        const collection = new Collection(collectionPath); 
        const runner = new Runner(); 
        const runSummary = await runner.run(collection); 
        return runSummary; 
    } 

    readExcelFile(filePath) { 
        const workbook = xlsx.readFile(filePath); 
        const sheetName = workbook.SheetNames[0]; 
        const sheet = workbook.Sheets[sheetName]; 
        const data = xlsx.utils.sheet_to_json(sheet); 
        return data; 
    } 

    generateHTMLReport(runSummary, outputFilePath) { 
        const htmlReport = newman.exports['html'](runSummary.run, null, { sanitizeNames: true }); 
        fs.writeFileSync(outputFilePath, htmlReport); 
    } 

    async main() { 
        const excelFilePath = 'path/to/youpath/to/your/excel/file.xlsx'; 
        const postmanCollectionPath = 'path/to/your/postman/collection.json'; 
        const htmlReportOutputPath = 'path/to/output/report.html'; 
        const excelData = this.readExcelFile(excelFilePath); 
        for (const row of excelData) { 
            const runSummary = await this.runPostmanCollection(postmanCollectionPath); 
            this.generateHTMLReport(runSummary, htmlReportOutputPath); 
        } 
    } 
}

const testRunPostmanCollection = new TestRunPostmanCollection(); 
testRunPostmanCollection.main(); 


test('Should run Postman collection', async () => {
    // Arrange
    const collectionPath = 'path/to/your/postman/collection.json';
    const expectedRunSummary = { run: { stats: { iterations: 1 } } };
    const runnerMock = jest.fn().mockResolvedValue(expectedRunSummary);
    const collectionMock = jest.fn().mockImplementation(() => ({
        run: runnerMock
    }));
    const fsMock = {
        writeFileSync: jest.fn()
    };
    const xlsxMock = {
        readFile: jest.fn().mockReturnValue({
            SheetNames: ['Sheet1'],
            Sheets: {
                Sheet1: {}
            }
        }),
        utils: {
            sheet_to_json: jest.fn().mockReturnValue([])
        }
    };
    const newmanExportsMock = {
        html: jest.fn().mockReturnValue('<html></html>')
    };
    global.Collection = collectionMock;
    global.Runner = jest.fn().mockImplementation(() => ({
        run: runnerMock
    }));
    global.newman = {
        exports: newmanExportsMock
    };
    global.fs = fsMock;
    global.xlsx = xlsxMock;

    // Act
    const runSummary = await runPostmanCollection(collectionPath);

    // Assert
    expect(collectionMock).toHaveBeenCalledWith(collectionPath);
    expect(runnerMock).toHaveBeenCalled();
    expect(fsMock.writeFileSync).toHaveBeenCalledWith('path/to/output/report.html', '<html></html>');
    expect(runSummary).toEqual(expectedRunSummary);
}); 


test('should read data from Excel file', () => { 
  const filePath = 'path/to/your/excel/file.xlsx'; 
  const expectedData = [{ key: 'value' }]; 
  const readFileSyncMock = jest.spyOn(fs, 'readFileSync').mockReturnValue(''); 
  const readFileMock = jest.spyOn(xlsx, 'readFile').mockReturnValue({ 
    SheetNames: ['Sheet1'], 
    Sheets: { 
      Sheet1: { 
        A1: { v: 'key' }, 
        B1: { v: 'value' } 
      } 
    } 
  }); 
  const sheetToJsonMock = jest.spyOn(xlsx.utils, 'sheet_to_json').mockReturnValue(expectedData); 
  const result = readExcelFile(filePath); 
  expect(result).toEqual(expectedData); 
  expect(readFileSyncMock).toHaveBeenCalledWith(filePath); 
  expect(readFileMock).toHaveBeenCalledWith(''); 
  expect(sheetToJsonMock).toHaveBeenCalledWith({ 
    A1: { v: 'key' }, 
    B1: { v: 'value' } 
  }); 
}); 


test('Should generate HTML report', async () => {
    // Arrange
    const collectionPath = 'path/to/your/postman/collection.json';
    const runSummary = { run: {} };
    const outputFilePath = 'path/to/output/report.html';
    const expectedHtmlReport = 'expected html report';
    const writeFileSyncMock = jest.spyOn(fs, 'writeFileSync').mockImplementation(() => {});
    const htmlReportMock = jest.spyOn(newman.exports, 'html').mockReturnValue(expectedHtmlReport);

    // Act
    await generateHTMLReport(runSummary, outputFilePath);

    // Assert
    expect(writeFileSyncMock).toHaveBeenCalledWith(outputFilePath, expectedHtmlReport);
    expect(htmlReportMock).toHaveBeenCalledWith(runSummary.run, null, { sanitizeNames: true });
}); 


test('Main function should run Postman collection for each row in the Excel data', () => {
  // Mock the necessary functions and data
  const excelData = [{}, {}];
  const runSummary = {};
  const generateHTMLReport = jest.fn();
  const runPostmanCollection = jest.fn().mockResolvedValue(runSummary);
  const readExcelFile = jest.fn().mockReturnValue(excelData);

  // Render the main function
  render(<main />);

  // Expect the necessary functions to be called for each row in the Excel data
  expect(readExcelFile).toHaveBeenCalledWith('path/to/your/excel/file.xlsx');
  expect(runPostmanCollection).toHaveBeenCalledTimes(2);
  expect(generateHTMLReport).toHaveBeenCalledTimes(2);
}); 


test('Execute the main function', async () => {
    // Mock the necessary functions
    jest.mock('fs');
    jest.mock('postman-runtime');
    jest.mock('xlsx');
    jest.mock('newman');

    // Mock the return values
    fs.readFileSync.mockReturnValue('path/to/your/excel/file.xlsx');
    fs.writeFileSync.mockReturnValue();
    xlsx.readFile.mockReturnValue({
        SheetNames: ['Sheet1'],
        Sheets: {
            Sheet1: {
                A1: { v: 'data1' },
                A2: { v: 'data2' }
            }
        }
    });
    xlsx.utils.sheet_to_json.mockReturnValue([{ data: 'data1' }, { data: 'data2' }]);
    newman.exports['html'].mockReturnValue('<html>Report</html>');
    runPostmanCollection.mockReturnValue({ run: 'runSummary' });

    // Execute the main function
    await main();

    // Check if the necessary functions are called
    expect(fs.readFileSync).toHaveBeenCalledWith('path/to/youpath/to/your/excel/file.xlsx');
    expect(fs.writeFileSync).toHaveBeenCalledWith('path/to/output/report.html', '<html>Report</html>');
    expect(xlsx.readFile).toHaveBeenCalledWith('path/to/your/excel/file.xlsx');
    expect(xlsx.utils.sheet_to_json).toHaveBeenCalledWith({
        A1: { v: 'data1' },
        A2: { v: 'data2' }
    });
    expect(newman.exports['html']).toHaveBeenCalledWith('runSummary', null, { sanitizeNames: true });
    expect(runPostmanCollection).toHaveBeenCalledWith('path/to/your/postman/collection.json');
}); 


